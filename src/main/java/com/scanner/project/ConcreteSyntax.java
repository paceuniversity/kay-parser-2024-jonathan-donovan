package com.scanner.project;

// ConcreteSyntax.java

// Implementation of the Recursive Descent Parser algorithm

// Each method corresponds to a concrete syntax grammar rule, 
// which appears as a comment at the beginning of the method.

// This code implements a parser for KAY based on the provided concrete syntax rules.

public class ConcreteSyntax {

    // Instance variables
    public Token token; // Current token being considered from the input stream
    public TokenStream input; // Stream of tokens generated by lexical analysis

    // Constructor
    public ConcreteSyntax(TokenStream ts) { 
        input = ts; // Set the input stream
        token = input.nextToken(); // Retrieve the first token
    }

    // Print a syntax error message
    private String SyntaxError(String tok) {
        String s = "Syntax error - Expecting: " + tok + " But saw: " 
                   + token.getType() + " = " + token.getValue();
        System.out.println(s);
        return s;
    }

    // Match a string with the value of a token
    private void match(String s) {
        if (token.getValue().equals(s))
            token = input.nextToken();
        else
            throw new RuntimeException(SyntaxError(s));
    }

    // Implementation of the Recursive Descent Parser

    public Program program() {
        // Program --> main { Declarations Statements }
        Program p = new Program();
        match("main");
        match("{");
        p.decpart = declarations(); // Parse declarations
        p.body = statements(); // Parse statements
        match("}");
        return p;
    }

    private Declarations declarations() {
        // Declarations --> { Declaration }*
        Declarations ds = new Declarations();
        while (token.getValue().equals("integer") || token.getValue().equals("bool")) {
            declaration(ds);
        }
        return ds;
    }

    private void declaration(Declarations ds) {
        // Declaration --> Type Identifiers ;
        Type t = type();
        identifiers(ds, t);
        match(";");
    }

    private Type type() {
        // Type --> integer | bool
        Type t;
        if (token.getValue().equals("integer") || token.getValue().equals("bool")) {
            t = new Type(token.getValue());
            token = input.nextToken(); // Move past type token
        } else {
            throw new RuntimeException(SyntaxError("integer | bool"));
        }
        return t;
    }

    private void identifiers(Declarations ds, Type t) {
        // Identifiers --> Identifier { , Identifier }*
        Declaration d = new Declaration();
        d.t = t;
        if (token.getType().equals("Identifier")) {
            d.v = new Variable();
            d.v.id = token.getValue();
            ds.addElement(d);
            token = input.nextToken(); // Move past identifier
            while (token.getValue().equals(",")) {
                token = input.nextToken(); // Skip comma
                d = new Declaration();
                d.t = t;
                if (token.getType().equals("Identifier")) {
                    d.v = new Variable();
                    d.v.id = token.getValue();
                    ds.addElement(d);
                    token = input.nextToken(); // Move past identifier
                } else {
                    throw new RuntimeException(SyntaxError("Identifier"));
                }
            }
        } else {
            throw new RuntimeException(SyntaxError("Identifier"));
        }
    }

    private Statement statement() {
        // Statement --> ; | Block | Assignment | IfStatement | WhileStatement
        Statement s;
        if (token.getValue().equals(";")) {
            token = input.nextToken();
            s = new Skip(); // Skip statement
        } else if (token.getValue().equals("{")) {
            token = input.nextToken();
            s = statements();
            match("}");
        } else if (token.getValue().equals("if")) {
            s = ifStatement();
        } else if (token.getValue().equals("while")) {
            s = whileStatement();
        } else if (token.getType().equals("Identifier")) {
            s = assignment();
        } else {
            throw new RuntimeException(SyntaxError("Statement"));
        }
        return s;
    }

    private Block statements() {
        // Block --> { Statements }
        Block b = new Block();
        while (!token.getValue().equals("}")) {
            b.blockmembers.addElement(statement());
        }
        return b;
    }

    private Assignment assignment() {
        // Assignment --> Identifier := Expression ;
        Assignment a = new Assignment();
        if (token.getType().equals("Identifier")) {
            a.target = new Variable();
            a.target.id = token.getValue();
            token = input.nextToken(); // Move past identifier
            match(":=");
            a.source = expression();
            match(";");
        } else {
            throw new RuntimeException(SyntaxError("Identifier"));
        }
        return a;
    }

    private Expression expression() {
        // Expression --> Conjunction { || Conjunction }*
        Expression e = conjunction();
        while (token.getValue().equals("||")) {
            Binary b = new Binary();
            b.term1 = e;
            b.op = new Operator(token.getValue());
            token = input.nextToken();
            b.term2 = conjunction();
            e = b;
        }
        return e;
    }

    private Expression conjunction() {
        // Conjunction --> Relation { && Relation }*
        Expression e = relation();
        while (token.getValue().equals("&&")) {
            Binary b = new Binary();
            b.term1 = e;
            b.op = new Operator(token.getValue());
            token = input.nextToken();
            b.term2 = relation();
            e = b;
        }
        return e;
    }

    private Expression relation() {
        // Relation --> Addition [ < | <= | > | >= | == | != ] Addition
        Expression e = addition();
        if (token.getValue().equals("<") || token.getValue().equals("<=") || token.getValue().equals(">")
                || token.getValue().equals(">=") || token.getValue().equals("==") || token.getValue().equals("!=")) {
            Binary b = new Binary();
            b.term1 = e;
            b.op = new Operator(token.getValue());
            token = input.nextToken();
            b.term2 = addition();
            e = b;
        }
        return e;
    }

    private Expression addition() {
        // Addition --> Term { [ + | - ] Term }*
        Expression e = term();
        while (token.getValue().equals("+") || token.getValue().equals("-")) {
            Binary b = new Binary();
            b.term1 = e;
            b.op = new Operator(token.getValue());
            token = input.nextToken();
            b.term2 = term();
            e = b;
        }
        return e;
    }

    private Expression term() {
        // Term --> Negation { [ '*' | / ] Negation }*
        Expression e = negation();
        while (token.getValue().equals("*") || token.getValue().equals("/")) {
            Binary b = new Binary();
            b.term1 = e;
            b.op = new Operator(token.getValue());
            token = input.nextToken();
            b.term2 = negation();
            e = b;
        }
        return e;
    }

    private Expression negation() {
        // Negation --> { ! }opt Factor
        if (token.getValue().equals("!")) {
            Unary u = new Unary();
            u.op = new Operator(token.getValue());
            token = input.nextToken();
            u.term = factor();
            return u;
        } else {
            return factor();
        }
    }

    private Expression factor() {
        // Factor --> Identifier | Literal | ( Expression )
        Expression e;
        if (token.getType().equals("Identifier")) {
            Variable v = new Variable();
            v.id = token.getValue();
            e = v;
            token = input.nextToken();
        } else if (token.getType().equals("Literal")) {
            if (token.getValue().equals("True")) {
                e = new Value(true);
            } else if (token.getValue().equals("False")) {
                e = new Value(false);
            } else if (isInteger(token.getValue())) {
                e = new Value(Integer.parseInt(token.getValue()));
            } else {
                throw new RuntimeException(SyntaxError("Literal"));
            }
            token = input.nextToken();
        } else if (token.getValue().equals("(")) {
            token = input.nextToken();
            e = expression();
            match(")");
        } else {
            throw new RuntimeException(SyntaxError("Identifier | Literal | ("));
        }
        return e;
    }

    private Conditional ifStatement() {
        // IfStatement --> if ( Expression ) Statement { else Statement }opt
        Conditional c = new Conditional();
        match("if");
        match("(");
        c.test = expression();
        match(")");
        c.thenbranch = statement();
        if (token.getValue().equals("else")) {
            token = input.nextToken();
            c.elsebranch = statement();
        }
        return c;
    }

    private Loop whileStatement() {
        // WhileStatement --> while ( Expression ) Statement
        Loop l = new Loop();
        match("while");
        match("(");
        l.test = expression();
        match(")");
        l.body = statement();
        return l;
    }

    private boolean isInteger(String s) {
        try {
            Integer.parseInt(s);
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
   
	}
}